;
; Sub routines for handling the physical screen and border
;

screen_width_pixels equ 256
screen_height_pixels equ 192
screen_width_chars equ 32
screen_height_chars equ 24

screen_start equ #4000
screen_size equ screen_width_chars * screen_height_pixels
attr_start equ #5800
attributes_length equ screen_width_chars * screen_height_chars


;
; Attributes for colors are
;
; %0-0-000-000
; flash-bright-paper-ink where:

black   equ #00				; %000000
blue    equ #01				; %000001
red     equ #02				; %000010
magenta equ #03				; %000011
green   equ #04				; %000100
cyan    equ #05				; %000101
yellow  equ #06				; %000110
white   equ #07				; %000111

pBlack   equ black << 3
pBlue    equ blue  << 3
pRed     equ red  << 3
pMagenta equ magenta  << 3
pGreen   equ green  << 3
pCyan    equ cyan  << 3
pYellow  equ yellow  << 3
pWhite   equ white  << 3

bright   equ #40			;%1000000

cls:	ld hl, screen_start
		ld de, screen_start + 1
		ld bc, screen_size
		ld (hl), 0
		ldir
		ld hl, attr_start
		ld de, attr_start+1
		ld bc, attributes_length
		ld (hl), a
		ldir
		ret

;
; Print a message to the screen
; In: IX + 0: Screen X 
;     IX + 1: Screen Y
;     IX + 2: Attributes
;     IX + 3: message (zero terminated)
;
print_message:	call get_char_addr		; get the screen address back
										; iterate the string and print each character
				push IX                 ; get ix into de
				pop de
				inc de                  ; move to start of message
				inc de
				inc de

				
print_loop:		ld a, (de)              ; if this is the last char to print clear the upper bit  
				and a, #7F				
				push hl                 ; save required registers
				push de
				push bc
				call print_char
				pop bc
				pop de
				pop hl

				ld a, (IX + 2)          ; store the attribute in the attribute map
				ld (bc), a

				ld a, (de)              ; Check current character for end of string
				bit 7, a                ; last char has upper bit set
				ret nz

				inc de                  ; Next character
				inc hl                  ; next screen address
				inc bc                  ; next attribute
				jr print_loop

				
				
;
; Given: IX points to x,y
; returns: hl => back buffer address of character
;          bc => attribute address of character ON SCREEN
get_char_addr:	ld h, 0                 ; calculate screenLoc = scan_line_00 + ((y*8) * 32)
				ld l, (IX + 1)          ; get the y coordinate

				add hl, hl              ; multiply it by 32*8 to get the row start
				add hl, hl
				add hl, hl
				add hl, hl
				add hl, hl
				add hl, hl
				add hl, hl
				add hl, hl

				ld bc, scan_line_000    ; top of screen
				add hl, bc              ; scan_line_00 + (y * 8 * with)
				ld b, 0
				ld c, (IX + 0)
				add hl, bc              ; scan_line_00 + (y * with) + x

				;
				; calculate attribute location = attributes start +x + (y*8)
				;
				push hl                 ; Calculate the first attribute position
				ld h, 0                 
				ld l, (IX + 1)          ; get the y coordinate
				                
				add hl, hl              ; hl = y * 8
				add hl, hl              
				add hl, hl              
				add hl, hl              
				add hl, hl              
				
				ld b,0
				ld c, (ix+0)
				add hl, bc              ; hl = x + (y * 8)
				ld bc, attr_line_000
				add hl, bc              ; add the offset to the start of the attribute block

				push hl                 ; swap HL and BC
				pop bc
				pop hl     
				

				
				ret

;
; print a character on the screen
; IN:   HL -> Screen address of the character
;       A  -> Character to pront (ascii)
print_char:		push hl					; save screen address
				cp "A"					; greater than or equal to A?
				jp nc, _isAlpha			; jump to print a..z
    
				cp "0"					; Greater than or equal to 0
				jp nc, _isDigit
    
				cp " "					; Is it a space?
				jp nz, _tryPeriod              
				ld hl, system_font_space
				jr _print_from_hl

_tryPeriod:		cp "."
				ret nz					; last chance is it a period, quit otherwise
				ld hl, system_font_full_stop
				jr _print_from_hl

_isDigit:		ld bc, system_font_09
				ld hl, 0
				sub '0'					; gets offset from '0'
				jp _offset_char

_isAlpha:		ld bc, system_font_az	; address of first char in the a-z set
				ld hl, 0
				sub 'A'					; get offset from A = 0

_offset_char:	ld l, a
				add hl, hl				; multiply offset by 8
				add hl, hl
				add hl, hl
				add hl, bc				; hl now points to first char in the character pix map

_print_from_hl:	push hl					; swap hl and de as hl is better at math
				pop  de					; de => font address
				pop  hl					; hl => screen address passed in
 
print_raw:		ld b, 8					; hl = screen address of char, de = font address, copy 8 lines of the character

_loop:			ld a, (de)
				ld (hl), a    
				inc de
				push bc
				ld bc, screen_width_chars
				add hl, bc
				pop bc
   
				djnz _loop         
				ret

